""" Justin Cappos -- substitute for a few python math routines"""

cmath = dy_import_module("cmath.r2py")


def math_ceil(x):
  xint = int(x)
  
  # if x is positive and not equal to itself truncated then we should add 1
  if x > 0 and x != xint:
    xint = xint + 1

  # I return a float because math.ceil does
  return float(xint)



def math_floor(x):
  xint = int(x)
  
  # if x is negative and not equal to itself truncated then we should subtract 1
  if x < 0 and x != xint:
    xint = xint - 1

  # I return a float because math.ceil does
  return float(xint)


# Reuse `cmath`'s definitions.
# The `math_*` ones are here just for compatibility with code that
# still relies on RepyV1 namespacing.
e = math_e = cmath.e
pi = math_pi = cmath.pi

# Algorithm from logN.py on
# http://en.literateprograms.org/Logarithm_Function_(Python)#chunk
# MIT license
#
# hmm, math_log(4.5,4)      == 1.0849625007211561
# Python's math.log(4.5,4)  == 1.0849625007211563
# I'll assume this is okay.
def math_log(X, base=e, epsilon=1e-16):
  # Make sure all arguments are floats, otherwise
  # * for integer X and base, the divisions below will truncate all
  #   decimals and the results will be wrong
  # * for complex epsilon, the greater-than test fails
  X = float(X)
  base = float(base)
  epsilon = float(epsilon)

  # JMC: The domain of the log function is {n | n > 0)
  if X <= 0:
    raise ValueError, "log function domain error"

  # log to the base 1 is undefined for X != 1, and has infinitely
  # many results for X == 1. Emulate Python's math.log's behavior,
  # though peculiar.
  if base == 1:
    raise ZeroDivisionError("float division by zero")

  # log is logarithm function with the default base of e
  integer = 0
  if X < 1 and base < 1:
    # BUG: the cmath implementation can handle smaller numbers...
    raise ValueError, "math domain error"
  while X < 1:
    integer -= 1
    X *= base
  while X >= base:
    integer += 1
    X /= base
  partial = 0.5               # partial = 1/2 
  X *= X                      # We perform a squaring
  decimal = 0.0
  while partial > epsilon:
    if X >= base:             # If X >= base then a_k is 1 
      decimal += partial      # Insert partial to the front of the list
      X = X / base            # Since a_k is 1, we divide the number by the base
    partial *= 0.5            # partial = partial / 2
    X *= X                    # We perform the squaring again
  return (integer + decimal)



def _noncomplex_numeric(x):
  """
  <Purpose>
    Wrapper to check that the argument is a non-complex numeric value.

  <Argument>
    A value to check for its non-complexity.

  <Exceptions>
    TypeError for non-numeric or complex arguments.

  <Returns>
    The same number if it is numeric but non-complex.
  """
  if type(x) not in (int, float):
    raise TypeError("a non-complex numeric argument is required")
  return x



def _into_plus_minus_pi(x):
  """
  <Purpose>
    Wrapper to wrap the argument into the interval (-pi, +pi),
    excluding enpoints.

  <Argument>
    A float or int value to wrap.

  <Exceptions>
    TypeError for non-numeric or complex arguments.

  <Returns>
    A float.
  """
  x = _noncomplex_numeric(x)

  x %= 2*pi

  if x >= pi:
    return x - 2*pi
  else:
    return x



def exp(x):
  """
  <Purpose>
    Function wrapper for the exponentiation of e, as often seen and used.

  <Argument>
    A float or int by which to exponentiate e.

  <Exceptions>
    TypeError for non-numeric or complex arguments, see Python's math/cmath.

  <Returns>
    A float.
  """
  x = _noncomplex_numeric(x)

  return e**x



def _get_real_from_cmath_with_wrapped_arg(cmath_function):
  """
  <Purpose>
    Internal helper function to return a function that calls into the `cmath`
    module. The returned function's argument is wrapped into (-pi, +pi).
    It only returns the real part of the complex `cmath` result.

  <Argument>
    A function in the `cmath` module that gets called.
    (The returned function then takes an argument that will be
    supplied to said `cmath` function.)

  <Exceptions>
    TypeError for non-numeric or complex arguments.
    Other errors per the implementation of `cmath_function`.

  <Returns>
    A float.
  """
  def inner_function(arg):
    return cmath_function(_into_plus_minus_pi(arg)).real
  return inner_function



# Sine, cosine and tangent are defined as the real-valued counterparts of
# the functions in `cmath.r2py`, with the call arg wrapped into (-pi, +pi).
"""
<Purpose>
  Return the sine, cosine, tangent of the argument (measured in radians).

<Argument>
  The desired angle in radians.

<Exceptions>
  See `exp`.

<Returns>
  A float.
"""
sin = _get_real_from_cmath_with_wrapped_arg(cmath.sin)
cos = _get_real_from_cmath_with_wrapped_arg(cmath.cos)
tan = _get_real_from_cmath_with_wrapped_arg(cmath.tan)



def atan(x):
  """
  <Purpose>
    Return the arc tangent, measured in radians, of the argument.

  <Argument>
    A float or int for which to find the arc tangent.

  <Exceptions>
    TypeError for non-numeric or complex arguments, see Python's math/cmath.

  <Returns>
    A float.

  <Note>
    The atan is calculated using a continued fraction:
    atan(x) = x / (1 + ((1*x)**2 / (3 + ((2*x)**2 / (5 + (3*x)**2 / (7 + (4*...
    To reduce the magnitude of arguments x handled, we pre-normalize the
    argument into (-1, 1). Normalization makes a final doubling of the
    result necessary.
    See Wikipedia for details:
      https://en.wikipedia.org/wiki/Inverse_trigonometric_functions
  """
  # Sum up this many iterations of the continued fraction expression.
  # Twelve steps suffice for an accuracy of 1e-14.
  STEPS = 12

  x = _noncomplex_numeric(x)

  # Wrap argument into (-1, 1). x already in this range get yet closer to 0.
  x = x/(1+(1+x**2)**0.5)

  # Cache x squared, we need it a lot
  xx = x**2

  # Initialize denominator to the last piece of the continued fraction,
  # ensure float.
  denominator = 2*STEPS + 1.0

  # Calculate the denominator of the continued fraction
  for n in range(STEPS, 0, -1):
    denominator = (2*n-1) + xx * n**2 / denominator

  # Bring in the numerator, double to adjust for the normalization step
  result = 2 * x / denominator

  return result

